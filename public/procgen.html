<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Mansion Generator</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 20px;
            background: #333;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-size: 12px;
            color: #ccc;
        }
        
        input, select, button {
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #555;
            color: #fff;
        }
        
        button {
            background: #666;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #777;
        }
        
        .generate-btn {
            background: #4a90e2;
            padding: 12px 24px;
            font-weight: bold;
        }
        
        .generate-btn:hover {
            background: #5aa3f5;
        }
        
        .canvas-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        canvas {
            border: 2px solid #555;
            border-radius: 8px;
            background: #222;
        }
        
        .info-panel {
            flex: 1;
            min-width: 300px;
            background: #333;
            padding: 20px;
            border-radius: 8px;
            height: fit-content;
        }
        
        .legend {
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #666;
        }
        
        .stats {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #555;
        }
        
        .stat-item {
            margin: 5px 0;
            font-size: 14px;
        }
        
        #debug {
            margin-top: 10px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Procedural Mansion Level Generator</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Algorithm</label>
                <select id="algorithm">
                    <option value="stealth">Stealth Optimized</option>
                    <option value="alcoves">Alcove Rooms</option>
                    <option value="pillars">Pillar Maze</option>
                    <option value="simple">Simple Rooms</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Width: <span id="widthValue">40</span></label>
                <input type="range" id="width" min="30" max="60" value="40">
            </div>
            
            <div class="control-group">
                <label>Height: <span id="heightValue">30</span></label>
                <input type="range" id="height" min="20" max="40" value="30">
            </div>
            
            <div class="control-group">
                <label>Rooms: <span id="roomsValue">6</span></label>
                <input type="range" id="rooms" min="3" max="12" value="6">
            </div>
            
            <button id="generate" class="generate-btn">Generate Mansion</button>
        </div>
        
        <div class="canvas-container">
            <canvas id="mansionCanvas" width="600" height="400"></canvas>
            
            <div class="info-panel">
                <h3>Level Information</h3>
                
                <div class="legend">
                    <h4>Legend</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #444;"></div>
                        <span>Wall</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f5f5dc;"></div>
                        <span>Floor</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8B4513;"></div>
                        <span>Door</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <span>Valuable</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF4444;"></div>
                        <span>Guard</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #44FF44;"></div>
                        <span>Player Start</span>
                    </div>
                </div>
                
                <div class="stats">
                    <h4>Statistics</h4>
                    <div id="stats">Click Generate to see stats</div>
                </div>
                
                <div id="debug">Debug: Ready</div>
            </div>
        </div>
    </div>

    <script>
        console.log("Script starting...");
        
        // Stealth-optimized generation with wall protrusions and hiding spots
        function generateStealthMansion(width, height, numRooms) {
            console.log("Generating stealth mansion:", width, height, numRooms);
            
            const grid = Array(height).fill(null).map(() => Array(width).fill(0));
            const rooms = [];
            const doors = [];
            const valuables = [];
            const guards = [];
            
            // Generate base rooms with irregular shapes
            for (let i = 0; i < numRooms; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const roomWidth = 8 + Math.floor(Math.random() * 10);
                    const roomHeight = 6 + Math.floor(Math.random() * 8);
                    const x = 3 + Math.floor(Math.random() * (width - roomWidth - 6));
                    const y = 3 + Math.floor(Math.random() * (height - roomHeight - 6));
                    
                    // Check overlap
                    let overlap = false;
                    for (let room of rooms) {
                        if (x < room.x + room.width + 3 && x + roomWidth + 3 > room.x &&
                            y < room.y + room.height + 3 && y + roomHeight + 3 > room.y) {
                            overlap = true;
                            break;
                        }
                    }
                    
                    if (!overlap) {
                        rooms.push({ x, y, width: roomWidth, height: roomHeight });
                        
                        // Create basic room
                        for (let ry = y; ry < y + roomHeight; ry++) {
                            for (let rx = x; rx < x + roomWidth; rx++) {
                                grid[ry][rx] = 1;
                            }
                        }
                        
                        // Add wall protrusions inside room for cover
                        addWallProtrusions(grid, x, y, roomWidth, roomHeight);
                        
                        // Add alcoves around room perimeter
                        addAlcoves(grid, x, y, roomWidth, roomHeight, width, height);
                        
                        break;
                    }
                    attempts++;
                }
            }
            
            // Connect rooms with corridors that have hiding spots
            connectRoomsWithHidingSpots(grid, rooms, width, height);
            
            // Place doors strategically
            placeDoors(rooms, doors);
            
            // Place valuables in challenging spots
            placeValuablesStrategically(rooms, valuables, grid);
            
            // Place guards with patrol considerations
            placeGuardsWithPatrols(rooms, guards, grid);
            
            const playerStart = rooms.length > 0 ? {
                x: rooms[0].x + 1,
                y: rooms[0].y + 1
            } : { x: 1, y: 1 };
            
            return { grid, rooms, doors, valuables, guards, playerStart };
        }
        
        // Add wall protrusions inside rooms for cover
        function addWallProtrusions(grid, roomX, roomY, roomWidth, roomHeight) {
            const numProtrusions = 2 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < numProtrusions; i++) {
                const side = Math.floor(Math.random() * 4);
                const size = 1 + Math.floor(Math.random() * 2);
                
                if (side === 0 && roomHeight > 4) { // Top wall
                    const startX = roomX + 2 + Math.floor(Math.random() * (roomWidth - 4));
                    for (let j = 0; j < size && roomY + j < roomY + roomHeight - 2; j++) {
                        grid[roomY + j][startX] = 0; // Wall
                    }
                } else if (side === 1 && roomWidth > 4) { // Right wall
                    const startY = roomY + 2 + Math.floor(Math.random() * (roomHeight - 4));
                    for (let j = 0; j < size && roomX + roomWidth - 1 - j > roomX + 1; j++) {
                        grid[startY][roomX + roomWidth - 1 - j] = 0;
                    }
                } else if (side === 2 && roomHeight > 4) { // Bottom wall
                    const startX = roomX + 2 + Math.floor(Math.random() * (roomWidth - 4));
                    for (let j = 0; j < size && roomY + roomHeight - 1 - j > roomY + 1; j++) {
                        grid[roomY + roomHeight - 1 - j][startX] = 0;
                    }
                } else if (side === 3 && roomWidth > 4) { // Left wall
                    const startY = roomY + 2 + Math.floor(Math.random() * (roomHeight - 4));
                    for (let j = 0; j < size && roomX + j < roomX + roomWidth - 2; j++) {
                        grid[startY][roomX + j] = 0;
                    }
                }
            }
        }
        
        // Add alcoves around room perimeter
        function addAlcoves(grid, roomX, roomY, roomWidth, roomHeight, mapWidth, mapHeight) {
            const numAlcoves = 1 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < numAlcoves; i++) {
                const side = Math.floor(Math.random() * 4);
                const alcoveSize = 1 + Math.floor(Math.random() * 2);
                
                if (side === 0 && roomY > alcoveSize) { // Top
                    const centerX = roomX + Math.floor(roomWidth / 2);
                    for (let ay = roomY - alcoveSize; ay < roomY; ay++) {
                        for (let ax = centerX - 1; ax <= centerX + 1; ax++) {
                            if (ax >= 0 && ax < mapWidth && ay >= 0) {
                                grid[ay][ax] = 1;
                            }
                        }
                    }
                } else if (side === 1 && roomX + roomWidth + alcoveSize < mapWidth) { // Right
                    const centerY = roomY + Math.floor(roomHeight / 2);
                    for (let ax = roomX + roomWidth; ax < roomX + roomWidth + alcoveSize; ax++) {
                        for (let ay = centerY - 1; ay <= centerY + 1; ay++) {
                            if (ax < mapWidth && ay >= 0 && ay < mapHeight) {
                                grid[ay][ax] = 1;
                            }
                        }
                    }
                } else if (side === 2 && roomY + roomHeight + alcoveSize < mapHeight) { // Bottom
                    const centerX = roomX + Math.floor(roomWidth / 2);
                    for (let ay = roomY + roomHeight; ay < roomY + roomHeight + alcoveSize; ay++) {
                        for (let ax = centerX - 1; ax <= centerX + 1; ax++) {
                            if (ax >= 0 && ax < mapWidth && ay < mapHeight) {
                                grid[ay][ax] = 1;
                            }
                        }
                    }
                } else if (side === 3 && roomX > alcoveSize) { // Left
                    const centerY = roomY + Math.floor(roomHeight / 2);
                    for (let ax = roomX - alcoveSize; ax < roomX; ax++) {
                        for (let ay = centerY - 1; ay <= centerY + 1; ay++) {
                            if (ax >= 0 && ay >= 0 && ay < mapHeight) {
                                grid[ay][ax] = 1;
                            }
                        }
                    }
                }
            }
        }
        
        // Generate rooms with built-in alcoves
        function generateAlcoveRooms(width, height, numRooms) {
            const grid = Array(height).fill(null).map(() => Array(width).fill(0));
            const rooms = [];
            const doors = [];
            const valuables = [];
            const guards = [];
            
            for (let i = 0; i < numRooms; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const roomWidth = 10 + Math.floor(Math.random() * 8);
                    const roomHeight = 8 + Math.floor(Math.random() * 6);
                    const x = 3 + Math.floor(Math.random() * (width - roomWidth - 6));
                    const y = 3 + Math.floor(Math.random() * (height - roomHeight - 6));
                    
                    let overlap = false;
                    for (let room of rooms) {
                        if (x < room.x + room.width + 4 && x + roomWidth + 4 > room.x &&
                            y < room.y + room.height + 4 && y + roomHeight + 4 > room.y) {
                            overlap = true;
                            break;
                        }
                    }
                    
                    if (!overlap) {
                        rooms.push({ x, y, width: roomWidth, height: roomHeight });
                        
                        // Create L-shaped or U-shaped rooms
                        const shape = Math.floor(Math.random() * 3);
                        
                        if (shape === 0) { // L-shape
                            createLShapedRoom(grid, x, y, roomWidth, roomHeight);
                        } else if (shape === 1) { // U-shape
                            createUShapedRoom(grid, x, y, roomWidth, roomHeight);
                        } else { // Rectangle with internal alcoves
                            createRoomWithInternalAlcoves(grid, x, y, roomWidth, roomHeight);
                        }
                        
                        break;
                    }
                    attempts++;
                }
            }
            
            connectRoomsWithHidingSpots(grid, rooms, width, height);
            placeDoors(rooms, doors);
            placeValuablesStrategically(rooms, valuables, grid);
            placeGuardsWithPatrols(rooms, guards, grid);
            
            const playerStart = rooms.length > 0 ? {
                x: rooms[0].x + 1,
                y: rooms[0].y + 1
            } : { x: 1, y: 1 };
            
            return { grid, rooms, doors, valuables, guards, playerStart };
        }
        
        function createLShapedRoom(grid, x, y, width, height) {
            const cutWidth = Math.floor(width * 0.4);
            const cutHeight = Math.floor(height * 0.4);
            
            // Fill main rectangle
            for (let ry = y; ry < y + height; ry++) {
                for (let rx = x; rx < x + width; rx++) {
                    grid[ry][rx] = 1;
                }
            }
            
            // Cut out corner (creates L-shape)
            for (let ry = y; ry < y + cutHeight; ry++) {
                for (let rx = x + width - cutWidth; rx < x + width; rx++) {
                    grid[ry][rx] = 0;
                }
            }
        }
        
        function createUShapedRoom(grid, x, y, width, height) {
            const cutWidth = Math.floor(width * 0.3);
            const cutHeight = Math.floor(height * 0.6);
            
            // Fill main rectangle
            for (let ry = y; ry < y + height; ry++) {
                for (let rx = x; rx < x + width; rx++) {
                    grid[ry][rx] = 1;
                }
            }
            
            // Cut out middle section (creates U-shape)
            const cutX = x + Math.floor((width - cutWidth) / 2);
            for (let ry = y; ry < y + cutHeight; ry++) {
                for (let rx = cutX; rx < cutX + cutWidth; rx++) {
                    grid[ry][rx] = 0;
                }
            }
        }
        
        function createRoomWithInternalAlcoves(grid, x, y, width, height) {
            // Fill main rectangle
            for (let ry = y; ry < y + height; ry++) {
                for (let rx = x; rx < x + width; rx++) {
                    grid[ry][rx] = 1;
                }
            }
            
            // Add internal wall segments for hiding
            const numWalls = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numWalls; i++) {
                const wallLength = 2 + Math.floor(Math.random() * 3);
                const horizontal = Math.random() < 0.5;
                
                if (horizontal && width > 6) {
                    const wallY = y + 2 + Math.floor(Math.random() * (height - 4));
                    const wallX = x + 2 + Math.floor(Math.random() * (width - wallLength - 2));
                    for (let j = 0; j < wallLength; j++) {
                        grid[wallY][wallX + j] = 0;
                    }
                } else if (!horizontal && height > 6) {
                    const wallX = x + 2 + Math.floor(Math.random() * (width - 4));
                    const wallY = y + 2 + Math.floor(Math.random() * (height - wallLength - 2));
                    for (let j = 0; j < wallLength; j++) {
                        grid[wallY + j][wallX] = 0;
                    }
                }
            }
        }
        
        // Generate pillar maze with lots of cover
        function generatePillarMaze(width, height, numRooms) {
            const grid = Array(height).fill(null).map(() => Array(width).fill(1)); // Start with all floor
            const rooms = [];
            const doors = [];
            const valuables = [];
            const guards = [];
            
            // Add border walls
            for (let x = 0; x < width; x++) {
                grid[0][x] = 0;
                grid[height - 1][x] = 0;
            }
            for (let y = 0; y < height; y++) {
                grid[y][0] = 0;
                grid[y][width - 1] = 0;
            }
            
            // Add pillar grid
            for (let y = 3; y < height - 3; y += 4) {
                for (let x = 3; x < width - 3; x += 4) {
                    // Create 2x2 pillars
                    grid[y][x] = 0;
                    grid[y][x + 1] = 0;
                    grid[y + 1][x] = 0;
                    grid[y + 1][x + 1] = 0;
                    
                    // Sometimes extend pillars for more cover
                    if (Math.random() < 0.3) {
                        if (x + 2 < width - 2) grid[y][x + 2] = 0;
                        if (y + 2 < height - 2) grid[y + 2][x] = 0;
                    }
                }
            }
            
            // Define room areas between pillars
            for (let i = 0; i < numRooms; i++) {
                const roomX = 6 + Math.floor(Math.random() * (width - 12)) & ~3; // Align to grid
                const roomY = 6 + Math.floor(Math.random() * (height - 12)) & ~3;
                rooms.push({ x: roomX, y: roomY, width: 8, height: 8 });
            }
            
            placeDoors(rooms, doors);
            placeValuablesStrategically(rooms, valuables, grid);
            placeGuardsWithPatrols(rooms, guards, grid);
            
            const playerStart = { x: 2, y: 2 };
            
            return { grid, rooms, doors, valuables, guards, playerStart };
        }
        
        // Connect rooms with corridors that have hiding spots
        function connectRoomsWithHidingSpots(grid, rooms, width, height) {
            for (let i = 0; i < rooms.length - 1; i++) {
                const roomA = rooms[i];
                const roomB = rooms[i + 1];
                
                const centerAX = Math.floor(roomA.x + roomA.width / 2);
                const centerAY = Math.floor(roomA.y + roomA.height / 2);
                const centerBX = Math.floor(roomB.x + roomB.width / 2);
                const centerBY = Math.floor(roomB.y + roomB.height / 2);
                
                // Create wider corridors (3 tiles wide)
                const corridorWidth = 3;
                const offset = Math.floor(corridorWidth / 2);
                
                // Horizontal corridor
                const startX = Math.min(centerAX, centerBX);
                const endX = Math.max(centerAX, centerBX);
                for (let y = centerAY - offset; y <= centerAY + offset; y++) {
                    for (let x = startX; x <= endX; x++) {
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            grid[y][x] = 1;
                        }
                    }
                }
                
                // Vertical corridor
                const startY = Math.min(centerAY, centerBY);
                const endY = Math.max(centerAY, centerBY);
                for (let x = centerBX - offset; x <= centerBX + offset; x++) {
                    for (let y = startY; y <= endY; y++) {
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            grid[y][x] = 1;
                        }
                    }
                }
                
                // Add wall segments in corridors for cover
                addCorridorCover(grid, centerAX, centerAY, centerBX, centerBY, width, height);
            }
        }
        
        function addCorridorCover(grid, x1, y1, x2, y2, width, height) {
            const numCovers = 1 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < numCovers; i++) {
                const t = (i + 1) / (numCovers + 1); // Position along path
                const coverX = Math.floor(x1 + (x2 - x1) * t);
                const coverY = Math.floor(y1 + (y2 - y1) * t);
                
                // Add small wall segment
                if (Math.random() < 0.5) { // Horizontal wall
                    for (let j = -1; j <= 1; j++) {
                        if (coverX + j >= 0 && coverX + j < width && coverY >= 0 && coverY < height) {
                            grid[coverY][coverX + j] = 0;
                        }
                    }
                } else { // Vertical wall
                    for (let j = -1; j <= 1; j++) {
                        if (coverX >= 0 && coverX < width && coverY + j >= 0 && coverY + j < height) {
                            grid[coverY + j][coverX] = 0;
                        }
                    }
                }
            }
        }
        
        function placeDoors(rooms, doors) {
            rooms.forEach(room => {
                const numDoors = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numDoors; i++) {
                    const side = Math.floor(Math.random() * 4);
                    let doorX, doorY;
                    
                    if (side === 0) { // Top
                        doorX = room.x + Math.floor(room.width / 2);
                        doorY = room.y;
                    } else if (side === 1) { // Right
                        doorX = room.x + room.width - 1;
                        doorY = room.y + Math.floor(room.height / 2);
                    } else if (side === 2) { // Bottom
                        doorX = room.x + Math.floor(room.width / 2);
                        doorY = room.y + room.height - 1;
                    } else { // Left
                        doorX = room.x;
                        doorY = room.y + Math.floor(room.height / 2);
                    }
                    
                    doors.push({ x: doorX, y: doorY });
                }
            });
        }
        
        function placeValuablesStrategically(rooms, valuables, grid) {
            rooms.forEach(room => {
                if (Math.random() < 0.8) { // 80% chance for valuable
                    // Try to place valuable in a corner or against a wall for stealth challenge
                    const corners = [
                        { x: room.x + 1, y: room.y + 1 },
                        { x: room.x + room.width - 2, y: room.y + 1 },
                        { x: room.x + 1, y: room.y + room.height - 2 },
                        { x: room.x + room.width - 2, y: room.y + room.height - 2 }
                    ];
                    
                    const validCorners = corners.filter(corner => 
                        corner.x > 0 && corner.x < grid[0].length && 
                        corner.y > 0 && corner.y < grid.length &&
                        grid[corner.y][corner.x] === 1
                    );
                    
                    if (validCorners.length > 0) {
                        const corner = validCorners[Math.floor(Math.random() * validCorners.length)];
                        valuables.push({
                            x: corner.x,
                            y: corner.y,
                            value: 100 + Math.floor(Math.random() * 500)
                        });
                    }
                }
            });
        }
        
        function placeGuardsWithPatrols(rooms, guards, grid) {
            rooms.forEach(room => {
                if (Math.random() < 0.4) { // 40% chance for guard
                    // Place guards in open areas where they can patrol
                    const centerX = room.x + Math.floor(room.width / 2);
                    const centerY = room.y + Math.floor(room.height / 2);
                    
                    if (grid[centerY] && grid[centerY][centerX] === 1) {
                        guards.push({
                            x: centerX,
                            y: centerY,
                            patrolRadius: 3 + Math.floor(Math.random() * 3)
                        });
                    }
                }
            });
        }
        
        // Render function
        function renderMansion(canvas, levelData, width, height) {
            console.log("Rendering mansion...");
            
            const ctx = canvas.getContext('2d');
            const cellSize = Math.min(canvas.width / width, canvas.height / height);
            
            canvas.width = width * cellSize;
            canvas.height = height * cellSize;
            
            const { grid, doors, valuables, guards, playerStart } = levelData;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tile = grid[y][x];
                    let color = '#444'; // Wall
                    
                    if (tile === 1) color = '#f5f5dc'; // Floor
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    // Draw grid lines
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
            
            // Draw doors
            ctx.fillStyle = '#8B4513';
            doors.forEach(door => {
                ctx.fillRect(door.x * cellSize, door.y * cellSize, cellSize, cellSize);
            });
            
            // Draw valuables
            ctx.fillStyle = '#FFD700';
            valuables.forEach(valuable => {
                ctx.fillRect(valuable.x * cellSize + 2, valuable.y * cellSize + 2, cellSize - 4, cellSize - 4);
            });
            
            // Draw guards
            ctx.fillStyle = '#FF4444';
            guards.forEach(guard => {
                ctx.beginPath();
                ctx.arc(guard.x * cellSize + cellSize/2, guard.y * cellSize + cellSize/2, cellSize/3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw player start
            if (playerStart) {
                ctx.fillStyle = '#44FF44';
                ctx.beginPath();
                ctx.arc(playerStart.x * cellSize + cellSize/2, playerStart.y * cellSize + cellSize/2, cellSize/4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            console.log("Rendering complete");
        }
        
        // Update stats
        function updateStats(levelData) {
            const { rooms, valuables, guards } = levelData;
            const totalValue = valuables.reduce((sum, v) => sum + v.value, 0);
            
            document.getElementById('stats').innerHTML = `
                <div class="stat-item"><strong>Rooms:</strong> ${rooms.length}</div>
                <div class="stat-item"><strong>Valuables:</strong> ${valuables.length}</div>
                <div class="stat-item"><strong>Guards:</strong> ${guards.length}</div>
                <div class="stat-item"><strong>Total Value:</strong> $${totalValue}</div>
            `;
        }
        
        // Main generation function
        function generateMansion() {
            console.log("Generate button clicked!");
            document.getElementById('debug').textContent = "Debug: Generating...";
            
            try {
                const width = parseInt(document.getElementById('width').value);
                const height = parseInt(document.getElementById('height').value);
                const rooms = parseInt(document.getElementById('rooms').value);
                const algorithm = document.getElementById('algorithm').value;
                
                console.log("Parameters:", { width, height, rooms, algorithm });
                
                let levelData;
                
                // Use different algorithms based on selection
                if (algorithm === 'stealth') {
                    levelData = generateStealthMansion(width, height, rooms);
                } else if (algorithm === 'alcoves') {
                    levelData = generateAlcoveRooms(width, height, rooms);
                } else if (algorithm === 'pillars') {
                    levelData = generatePillarMaze(width, height, rooms);
                } else {
                    levelData = generateSimpleMansion(width, height, rooms);
                }
                
                console.log("Generated level data:", levelData);
                
                const canvas = document.getElementById('mansionCanvas');
                renderMansion(canvas, levelData, width, height);
                updateStats(levelData);
                
                document.getElementById('debug').textContent = `Debug: Generated ${levelData.rooms.length} rooms`;
                
            } catch (error) {
                console.error("Error generating mansion:", error);
                document.getElementById('debug').textContent = "Debug: Error - " + error.message;
            }
        }
        
        // Update slider values
        function updateSliders() {
            document.getElementById('widthValue').textContent = document.getElementById('width').value;
            document.getElementById('heightValue').textContent = document.getElementById('height').value;
            document.getElementById('roomsValue').textContent = document.getElementById('rooms').value;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, initializing...");
            
            // Add event listeners
            document.getElementById('generate').addEventListener('click', generateMansion);
            
            document.getElementById('width').addEventListener('input', updateSliders);
            document.getElementById('height').addEventListener('input', updateSliders);
            document.getElementById('rooms').addEventListener('input', updateSliders);
            
            // Initial setup
            updateSliders();
            
            // Generate initial mansion
            setTimeout(generateMansion, 100);
            
            document.getElementById('debug').textContent = "Debug: Initialized";
        });
        
        console.log("Script loaded");
    </script>
</body>
</html>
